/*
 * File          : CallConstraint.java
 * Project       : jlift
 * Description   : Represents a call from to a procedure in the same SCC.
 * Author(s)     : dhking
 *
 * Created       : Dec 4, 2007 8:42:40 AM
 *
 * Copyright (c) 2007 The Pennsylvania State University
 * Systems and Internet Infrastructure Security Laboratory
 *
 */

package jlift.types;

import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import jif.types.JifContext;
import jif.types.JifParsedPolyType;
import jif.types.JifProcedureInstance;
import jif.types.JifSubstType;
import jif.types.JifTypeSystem;
import jif.types.LabelSubstitution;
import jif.types.Param;
import jif.types.label.CovariantParamLabel;
import jif.types.label.Label;
import jif.types.label.ParamLabel;
import jif.types.label.VarLabel;
import jif.types.principal.Principal;
import jlift.JLiftOptions;
import jlift.SummaryConstraintInfo;
import jlift.types.label.JLiftInstLabel_c;
import jlift.types.label.SummaryVarLabel;
import jlift.types.principal.JLiftDynamicPrincipal_c;
import jlift.util.Pair;
import jlift.visit.SummaryConstraintGenerator;
import polyglot.ast.Expr;
import polyglot.ast.Node;
import polyglot.main.Report;
import polyglot.types.ArrayType;
import polyglot.types.ConstructorInstance;
import polyglot.types.ProcedureInstance;
import polyglot.types.SemanticException;
import polyglot.types.Type;
import polyglot.util.InternalCompilerError;
import polyglot.util.Position;

public class CallConstraint {

	protected JifProcedureInstance jpi;
	protected Label caller_pc;
	protected List<Type> actualArgTypes;
	protected List<Label> actualArgLabels;
	protected Node node;
	protected LabelSubstitution rvSubst;
	protected Expr receiver;
	protected List<Type> actualFormalTypes;

	// represents the constraints generated by a call of a method -- used
	// for mutually recursive functions

	public CallConstraint(JifProcedureInstance jpi, List<Type> actualArgTypes, List<Label> actualArgLabels, List<Type> actualFormalTypes, Label caller_pc, Expr receiver, Node node)
	{
		this.jpi = jpi;
		this.caller_pc = caller_pc;
		this.actualArgTypes = actualArgTypes;
		this.actualArgLabels = actualArgLabels;
		this.actualFormalTypes = actualFormalTypes;
		this.node = node;
		this.receiver = receiver;
	}

	@Override
	public String toString()
	{
		return jpi.toString() + "[" + actualArgLabels.toString() + "]@pc = " + caller_pc;
	}

	public void setCallerPc(Label caller_pc) {
		this.caller_pc = caller_pc;
	}

	public void setActualArgLabels(List<Label> actualArgs) {
		this.actualArgLabels = actualArgs;
	}

	public void setProcedureInstance(JifProcedureInstance jpi) {
		this.jpi = jpi;
	}

	public Label caller_pc() {
		return caller_pc;
	}

	public List<Label> getActualArgLabels() {
		return actualArgLabels;
	}

	public JifProcedureInstance getProcedureInstance() {
		return jpi;
	}

	@Override
	public int hashCode() {
		return toString().hashCode();
	}

	@Override
	public boolean equals(Object o) {
		return toString().equals(((CallConstraint) o).toString());
	}

	@Override
	public CallConstraint clone() {
		CallConstraint cc = new CallConstraint(jpi, actualArgTypes, actualArgLabels, actualFormalTypes, caller_pc, receiver, node);
		cc.rvSubst = this.rvSubst;

		return cc;
	}

	public Node getNode() {
		return node;
	}

	public void setNode(Node node) {
		this.node = node;
	}

	public LabelSubstitution getReturnValueSubst() {
		return rvSubst;
	}

	public void setReturnValueSubst(LabelSubstitution rvSubst) {
		this.rvSubst = rvSubst;
	}

	public CallConstraint subst(LabelSubstitution ls) throws SemanticException {
		CallConstraint cc = this.clone();
		List<Label> newActualArgs = new LinkedList<Label>();
		for(Label l : cc.actualArgLabels) {
			newActualArgs.add(l.subst(ls));
		}
		cc.caller_pc = cc.caller_pc.subst(ls);

		return cc;
	}

	public void setReceiver(Expr receiver) {
		this.receiver = receiver;
	}

	public Expr getReceiver() {
		return receiver;
	}

	private LabelSubstitution getReturnValueSubstitution() {
		if (this.rvSubst == null) {
			createReturnValueSubstitution();
		}
		return this.rvSubst;
	}

	private void createReturnValueSubstitution() {
		JLiftTypeSystem jts = (JLiftTypeSystem) jpi.typeSystem();
		if (jpi instanceof JLiftMethodInstance_c) {
			JLiftMethodInstance_c jmi = (JLiftMethodInstance_c) jpi;
			final VarLabel current_rv = jmi.summaryVarLabel();
			if (current_rv != null && current_rv instanceof SummaryVarLabel) {
				String oldName = current_rv.name();

				final VarLabel replace_rv =
					jts.freshLabelVariable(this.node.position(),
							oldName.substring(4, oldName.length() - 1) + "@callto:" + SummaryConstraintInfo.getNameForProcedureInstance(jpi),
							current_rv.description());

				LabelSubstitution ls = new LabelSubstitution() {
					@Override
					public Label substLabel(Label L) throws SemanticException {
						if (L.equals(current_rv))
							return replace_rv;
						return L;
					}
				};

				this.rvSubst  = ls;
			}
		}
	}

	public Label substLabel(Label labelToInstantiate) throws SemanticException {
		LabelSubstitution ls = getReturnValueSubstitution();
		if (ls != null) {
			return labelToInstantiate.subst(ls);
		}

		return labelToInstantiate;
	}



	public LabelSubstitution getParamSubst(Collection<JLiftLabelConstraint> newConstraints) {
		JLiftTypeSystem jts = (JLiftTypeSystem) jpi.typeSystem();
		Type type;
		Position exprPosition;

		if (getReceiver() != null) {
			type = jts.unlabel(getReceiver().type());
			exprPosition = getReceiver().position();
		}
		else if (jpi instanceof ConstructorInstance) {
			// if we're making a constructor call without a receiver, this might also have introduced param labels
			ConstructorInstance ci = (ConstructorInstance) jpi;
			type = ci.container();
			exprPosition = getNode().position();
		}
		else if (jpi.flags().isStatic()) {
			type = jpi.container();
			exprPosition = getNode().position();
		}
		else {
			// why would this happen?

			System.out.println("no receiver, and not a constructor??? " + jpi + " and " + jpi.flags() + " with " + jpi.container());
			return null;
		}

		List<Label> actuals = getActualLabelsFromParameterizedType(type);
		List<Label> paramLabels = getSubstParamLabelsFromParameterizedType(type);
		final Map<Label, VarLabel> substMap = new HashMap<Label, VarLabel>();

		if (actuals == null || paramLabels == null)
			return null;

		Iterator<Label> itActuals = actuals.iterator();
		Iterator<Label> itParam = paramLabels.iterator();

		while(itActuals.hasNext()) {
			Label actual = itActuals.next();

			if (!itParam.hasNext()) {
				System.out.println("ABOUT TO DIE -- call is " + this.jpi + " at position " + this.node.position() + " (" + this.node + ")");
				System.out.println("actuals: " + actuals);
				System.out.println("paramLabels: " + paramLabels);
				System.out.println("type: " + type);
			}

			Label param = itParam.next();

			// the parameter label without the []s
			String paramName = getParamNameFromLabel(param);

			if (Report.should_report("summary", 4))
				Report.report(4, "param substitution: " + actual + " for " + param + " in constraint set");
			// first off, get a fresh variable representing the OLD param label, substitute FOR
			// that fresh variable, then set actual = variable
			VarLabel paramReplaceVar = jts.freshLabelVariable(param.position(), paramName + ":param@" + exprPosition, "variable to replace param " + param);
			substMap.put(param, paramReplaceVar);

			JLiftLabelConstraint argConstraint =
				SummaryConstraintGenerator.equalitylabelConstraint(paramReplaceVar,
						actual,
						jts.createLabelEnv(),
						actual.position());
			argConstraint.setNode(getNode());

			newConstraints.add(argConstraint);
		}

		LabelSubstitution paramSubst = new LabelSubstitution() {
			@Override
			public Label substLabel(Label L) throws SemanticException {
				if (L instanceof ParamLabel) {
					ParamLabel pl = (ParamLabel) L;
					if (substMap.containsKey(pl)) {
						return substMap.get(pl);
					}
				}
				return super.substLabel(L);
			}
		};

		return paramSubst;
	}

	private String getParamNameFromLabel(Label param) {
		if (param instanceof ParamLabel)
			return ((ParamLabel) param).paramInstance().name();
		if (param instanceof CovariantParamLabel)
			return ((CovariantParamLabel) param).paramInstance().name();

		return null;
	}

	public static List<Label> getActualLabelsFromParameterizedType(Type type) {
		if (type instanceof JifSubstType) {
			JifSubstType js =  (JifSubstType) type;
			List<Label> returnLabels = new LinkedList<Label>();
			for (Param p : (Collection<Param>) js.actuals()) {
				if (p instanceof Label)
					returnLabels.add((Label) p);
			}
			return returnLabels;
		}

		return null;
	}

	public static List<Label> getSubstParamLabelsFromParameterizedType(Type type) {
		if (type instanceof JifSubstType) {
			JifSubstType js =  (JifSubstType) type;
			if (js.base() instanceof JifParsedPolyType) {
				JifParsedPolyType jppt = (JifParsedPolyType) js.base();

				List<Label> returnParamLabels = new LinkedList<Label>();

				for (Param p : (Collection<Param>) jppt.actuals()) {
					if (p instanceof ParamLabel)
						returnParamLabels.add((ParamLabel) p);
					if (p instanceof CovariantParamLabel)
						returnParamLabels.add((CovariantParamLabel) p);
				}

				return returnParamLabels;
			}
		}

		return null;
	}

	public Pair<SummaryVarLabel, Label> getArrayBaseSubst(Type actualType, Type formalType) {
		JifTypeSystem jts = (JifTypeSystem) formalType.typeSystem();
		Type unlabeledType = jts.unlabel(formalType);
		Type unlabeledActualType = jts.unlabel(actualType);

		if (unlabeledType instanceof ArrayType) {
			ArrayType at = (ArrayType) unlabeledType;
			if (jts.labelOfType(at.base()) instanceof SummaryVarLabel) {
				SummaryVarLabel varBaseLabel = (SummaryVarLabel) jts.labelOfType(at.base());
				if (unlabeledActualType instanceof ArrayType) {
					// great, time to get the label on this type
					Label actualBaseLabel = jts.labelOfType(((ArrayType) unlabeledActualType).base());
					// substitute actualBaseLabel for varBaseLabel
					if (Report.should_report("summary", 7))
						Report.report(7, "substituting " + actualBaseLabel + " for " + varBaseLabel + " (array actual for array variable)");

					return new Pair<SummaryVarLabel, Label>(varBaseLabel, actualBaseLabel);
				}
			}
		}

		return null;
	}

	public List<Type> getActualArgTypes() {
		return this.actualArgTypes;
	}

	public void setActualArgTypes(List<Type> actualTypes) {
		this.actualArgTypes = actualTypes;
	}

	public void setActualFormalTypes(List<Type> actualFormals) {
		this.actualFormalTypes = actualFormals;
	}

	public List<Type> getActualFormalTypes() {
		return this.actualFormalTypes;
	}

	public void getConstraintsFromCall(SummaryConstraintInfo summaryConstraintInfo,
									   JifContext jifContext,
									   Collection<JLiftLabelConstraint> returnLabelConstraints,
									   Collection<CallConstraint> returnCallConstraints) throws SemanticException
	{
		returnLabelConstraints.clear();
		returnCallConstraints.clear();

		Collection<JLiftLabelConstraint> labelConstraintsToReturn = new LinkedHashSet<JLiftLabelConstraint>();
		Collection<CallConstraint> callConstraintsToReturn = new LinkedHashSet<CallConstraint>();

		ProcedureInstance called = getProcedureInstance();
		List<Label> calledFormalLabels = summaryConstraintInfo.getLabelsFromFormalTypes(called);
		Iterator<Label> itActuals = getActualArgLabels().iterator();

		for(JLiftLabelConstraint c : summaryConstraintInfo.getSummaryConstraints(called)) {
			JLiftLabelConstraint constraintToAdd = c;
			if (JLiftOptions.getInstance().imperativeSubstitution)
				constraintToAdd = c.clone();
			labelConstraintsToReturn.add(constraintToAdd);
		}

		for(CallConstraint cc : summaryConstraintInfo.getCallConstraints(called)) {
			callConstraintsToReturn.add(cc);
		}

		if (Report.should_report("summary", 20)) {
			Report.report(20, "UNSUBSTITUTED LABEL CONSTRAINTS FROM CALL TO " + this.getProcedureInstance());
			summaryConstraintInfo.reportConstraintSet((Collection) labelConstraintsToReturn, 20);
		}

		// now, do substitutions

		String procedureName = SummaryConstraintInfo.getNameForProcedureInstance(getProcedureInstance());
		Position pos = getNode().position();

		if (summaryConstraintInfo.shouldRenameConstraintsFromCall(jpi)) {
			labelConstraintsToReturn = summaryConstraintInfo.renameVariablesInCall((JLiftTypeSystem) getProcedureInstance().typeSystem(), labelConstraintsToReturn, pos);
		}

		// add subtype constraints
		Iterator<Type> itActualArgs = getActualArgTypes().iterator();
		Iterator<Type> itFormalArgs = getProcedureInstance().formalTypes().iterator();

		JifTypeSystem jts = (JifTypeSystem) jpi.typeSystem();

		while(itActualArgs.hasNext()) {
			Type actual = itActualArgs.next();
			Type formalType = itFormalArgs.next();

			try {
				summaryConstraintInfo.addConstraintsFromSubtypeChecker(labelConstraintsToReturn, this, actual, formalType, jpi);
			} catch (SemanticException e) {
				throw e;
			}
		}

		// substitute actuals for formals, if the formal is a summary varlabel
		for(Label l : calledFormalLabels)
		{
			Label actualj = itActuals.next();

			if (l instanceof SummaryVarLabel) {
				SummaryVarLabel sv = (SummaryVarLabel) l;

				labelConstraintsToReturn = SummaryConstraintInfo.substituteAwaySummaryVariableInConstraintSet(jifContext, sv, actualj, labelConstraintsToReturn, procedureName, pos);
				callConstraintsToReturn = SummaryConstraintInfo.substituteInCallConstraintSet(sv, actualj, callConstraintsToReturn);
			}
		}

		// substitute array bounds
		itActualArgs = getActualArgTypes().iterator();
		itFormalArgs = getProcedureInstance().formalTypes().iterator();
		while(itActualArgs.hasNext()) {
			Type actual = itActualArgs.next();
			Type formalType = itFormalArgs.next();

			Pair<SummaryVarLabel, Label> substPair = getArrayBaseSubst(actual, formalType);

			if (substPair != null) {
				labelConstraintsToReturn = SummaryConstraintInfo.substituteAwaySummaryVariableInConstraintSet(jifContext, substPair.getFirst(), substPair.getSecond(), labelConstraintsToReturn, procedureName, pos);
				callConstraintsToReturn = SummaryConstraintInfo.substituteInCallConstraintSet(substPair.getFirst(), substPair.getSecond(), callConstraintsToReturn);
			}
		}

		// then substitute the pc bound, if the pc bound is a summary varlabel
		if (called instanceof JifProcedureInstance) {
			JifProcedureInstance calledjpi = (JifProcedureInstance) called;
			if (calledjpi.pcBound() instanceof SummaryVarLabel) {
				SummaryVarLabel pcVar = (SummaryVarLabel) calledjpi.pcBound();
				// need a new variable to serve as the replacement variable

				labelConstraintsToReturn = SummaryConstraintInfo.substituteAwaySummaryVariableInConstraintSet(jifContext, pcVar, caller_pc(), labelConstraintsToReturn, procedureName, pos);
				//labelConstraintsToReturn = substituteInConstraintSet(pcVar, call.caller_pc(), labelConstraintsToReturn);
				callConstraintsToReturn = SummaryConstraintInfo.substituteInCallConstraintSet(pcVar, caller_pc(), callConstraintsToReturn);
			}
		}

		LabelSubstitution rvSubst = getReturnValueSubst();
		if (rvSubst != null) {
			labelConstraintsToReturn = SummaryConstraintInfo.applyLabelSubstitutionToConstraintSet(rvSubst, labelConstraintsToReturn);
			callConstraintsToReturn = SummaryConstraintInfo.applyLabelSubstitutionToCallConstraintSet(rvSubst, callConstraintsToReturn);
		}

		LabelSubstitution paramSubst = getParamSubst(labelConstraintsToReturn);
		if (paramSubst != null) {
			labelConstraintsToReturn = SummaryConstraintInfo.applyLabelSubstitutionToConstraintSet(paramSubst, labelConstraintsToReturn);
			callConstraintsToReturn = SummaryConstraintInfo.applyLabelSubstitutionToCallConstraintSet(paramSubst, callConstraintsToReturn);
		}

		if (getReceiver() != null) {
			Label receiverLabel = summaryConstraintInfo.jts.labelOfType(getReceiver().type());
			labelConstraintsToReturn = SummaryConstraintInfo.substituteAwayThisLabelInConstraintSet(procedureName + "_receiver", pos, receiverLabel, labelConstraintsToReturn, summaryConstraintInfo.jts);
			// TODO: substitute away 'this' in callConstraints
		}


		if (JLiftOptions.getInstance().dynamicLabelAnalysis) {
			// add subtype constraints
			itActualArgs = getActualArgTypes().iterator();
			itFormalArgs = getProcedureInstance().formalTypes().iterator();

			System.out.println("DYNAMIC LABEL SUBSTITUTION BECAUSE OF CALL " + this.node);

			while(itActualArgs.hasNext()) {
				Type actual = itActualArgs.next();
				Type formalType = itFormalArgs.next();

				if (jts.isLabel(jts.unlabel(actual)) && jts.isLabel(jts.unlabel(formalType))) {
					System.err.println(jts.unlabel(formalType) + " (" +jts.unlabel(formalType).getClass() + ")");
					int formalId = ((LabelPrimitiveType_c) jts.unlabel(formalType)).id();
					int actualId = ((LabelPrimitiveType_c) jts.unlabel(actual)).id();
					System.err.println("\tsubstitute label " + formalType + " (" + formalId + ") with " + actual + " (" + actualId + ")");

					labelConstraintsToReturn = substituteInstLabelInConstraintSet(labelConstraintsToReturn, formalId, actualId);
				}
				if (jts.isPrincipal(jts.unlabel(actual)) && jts.isPrincipal(jts.unlabel(formalType))) {
					System.err.println("\tsubstitute principal " + formalType + " with " + actual);
					int formalId = ((PrincipalPrimitiveType_c) jts.unlabel(formalType)).id();
					int actualId = ((PrincipalPrimitiveType_c) jts.unlabel(actual)).id();

					labelConstraintsToReturn = substitutePrincipalInConstraintSet(labelConstraintsToReturn, formalId, actualId);
				}
			}
		}

		returnLabelConstraints.addAll(labelConstraintsToReturn);
		returnCallConstraints.addAll(callConstraintsToReturn);

		if (Report.should_report("summary", 20)) {
			Report.report(20, "RETURNING LABEL CONSTRAINTS FROM CALL TO " + this.getProcedureInstance());
			SummaryConstraintInfo.reportConstraintSet((Collection) returnLabelConstraints, 20);
		}
	}

    private Collection<JLiftLabelConstraint> substitutePrincipalInConstraintSet(
			Collection<JLiftLabelConstraint> conSet,
			final int oldId, final int newId) {
    	Collection<JLiftLabelConstraint> returnSet = new LinkedList<JLiftLabelConstraint>();
    	LabelSubstitution ls = new LabelSubstitution() {
    		@Override
    		public Principal substPrincipal(Principal p)
    				throws SemanticException {
    			if (p instanceof JLiftDynamicPrincipal_c) {
    				JLiftDynamicPrincipal_c jdp = (JLiftDynamicPrincipal_c) p;
    				if (jdp.id() == oldId)
    					return jdp.id(newId);
    			}
    			return super.substPrincipal(p);
    		}
    	};
    	try {
    		for(JLiftLabelConstraint c : conSet) {
    			JLiftLabelConstraint substConstraint = c.subst(ls);
    			if (!substConstraint.toString().equals(c.toString()))
    				System.err.println(c + " --> " + substConstraint);
    			returnSet.add(substConstraint);

    		}
    	} catch (SemanticException e) {
    		throw new InternalCompilerError(e);
    	}

    	return returnSet;
	}

    private Collection<JLiftLabelConstraint> substituteInstLabelInConstraintSet(Collection<JLiftLabelConstraint> conSet, final int oldId, final int newId) {
    	Collection<JLiftLabelConstraint> returnSet = new LinkedList<JLiftLabelConstraint>();
    	LabelSubstitution ls = new LabelSubstitution() {
    		@Override
    		public Label substLabel(Label L) {
    			//System.err.println("L: " + L);
    			if (L instanceof JLiftInstLabel_c) {
    				JLiftInstLabel_c jil = (JLiftInstLabel_c) L;
    				//System.err.println("jil: " + jil + " (id: " + jil.id() + ") -- subbing " + oldId + " for " + newId);
    				Label returnLabel = jil.subst(oldId, newId);
    				System.err.println(jil + " vs " + returnLabel);
    				return returnLabel;
    			}

    			return L;
    		}
    	};

    	try {
    		for(JLiftLabelConstraint c : conSet) {
    			JLiftLabelConstraint substConstraint = c.subst(ls);
    			if (!substConstraint.toString().equals(c.toString()))
    				System.err.println(c + " --> " + substConstraint);
    			returnSet.add(substConstraint);

    		}
    	} catch (SemanticException e) {
    		throw new InternalCompilerError(e);
    	}

    	return returnSet;
    }

//  private Collection<JLiftLabelConstraint> substituteParamLabelsFromCall(
//  CallConstraint call,
//  Collection<JLiftLabelConstraint> constraintsFromCall,
//  Node currentNode) {
//  Type type = null;
//  Position exprPosition = null;
//  Collection<JLiftLabelConstraint> returnConstraintsFromCall = constraintsFromCall;



//  if (type instanceof JifSubstType) {
//  JifSubstType js = (JifSubstType) type;
//  if (js.base() instanceof JifParsedPolyType) {
//  JifParsedPolyType jppt = (JifParsedPolyType) js.base();

//  Iterator<Label> itActuals = js.actuals().iterator();
//  Iterator<ParamLabel> itSubstParams = jppt.actuals().iterator();

//	while(itActuals.hasNext()) {
//	Label actual = itActuals.next();
//	ParamLabel param = itSubstParams.next();

//	// the parameter label without the []s
//	String paramName = param.paramInstance().name();

//	if (Report.should_report("summary", 4))
//	Report.report(4, "param substitution: " + actual + " for " + param + " in constraint set");
//	// first off, get a fresh variable representing the OLD param label, substitute FOR
//	// that fresh variable, then set actual = variable
//	VarLabel paramReplaceVar = jts.freshLabelVariable(param.position(), paramName + ":param@" + exprPosition, "variable to replace param " + param);
//	returnConstraintsFromCall = SummaryConstraintInfo.substituteInConstraintSet(param, paramReplaceVar, returnConstraintsFromCall);

//	JLiftLabelConstraint argConstraint =
//	SummaryConstraintGenerator.equalitylabelConstraint(paramReplaceVar,
//	actual,
//	jts.createLabelEnv(),
//	actual.position());
//	argConstraint.setNode(call.getNode());

//	returnConstraintsFromCall.add(argConstraint);
//	}
//	}
//	}

//	return returnConstraintsFromCall;
//	}
}
