/*
 * File          : SummaryConstraintVisitor.java
 * Project       : jlift
 * Description   : Visitor that generates summary constraints for a specific method.
 * Author(s)     : dhking
 *
 * Created       : Dec 4, 2007 10:17:13 AM
 *
 * Copyright (c) 2007 The Pennsylvania State University
 * Systems and Internet Infrastructure Security Laboratory
 *
 */

package jlift.visit;

import jif.types.JifContext;
import jif.types.JifProcedureInstance;
import jlift.SummaryConstraintInfo;
import polyglot.ast.ClassDecl;
import polyglot.ast.Node;
import polyglot.ast.NodeFactory;
import polyglot.ast.ProcedureDecl;
import polyglot.frontend.Job;
import polyglot.main.Report;
import polyglot.types.ProcedureInstance;
import polyglot.types.SemanticException;
import polyglot.types.TypeSystem;
import polyglot.visit.ErrorHandlingVisitor;
import polyglot.visit.NodeVisitor;

// the SummaryConstraintGenerator will generate the summary
// function for a strongly connected component of the call graph

public class SummaryConstraintVisitor extends ErrorHandlingVisitor implements Runnable
{
	// ASSUMPTION: we are being called in SCC order, i.e.
	// there exist summary functions in all the methods were are
	// calling beneath us

	// this is going to be very similar to the LabelCheckVisitor,
	// except when it reaches a method, it will change the header,
	// generate the constraints (with .labelCheck), and then tag
	// that function with those generated constraints

	protected ProcedureInstance method;
	protected SummaryConstraintGenerator slc;
	protected SummaryConstraintInfo summaryInfo;
	protected Node ast;

	public SummaryConstraintVisitor(Job job, TypeSystem ts, NodeFactory nf, ProcedureInstance proc, SummaryConstraintGenerator slc, SummaryConstraintInfo summaryInfo, Node ast)
	{
		super(job, ts, nf);
		this.method = proc;
		this.slc = slc;
		this.summaryInfo = summaryInfo;
		this.ast = ast;
	}

	@Override
	public NodeVisitor enterCall(Node n) throws SemanticException
	{
		if (n instanceof ClassDecl)
		{
			// we need to add a classdecl to the context
			ClassDecl cd = (ClassDecl) n;

			JifContext A = slc.jifContext();
			A = (JifContext)A.pushClass(cd.type(), cd.type());
			return new SummaryConstraintVisitor(job, ts, nf, method, (SummaryConstraintGenerator) slc.context(A), summaryInfo, ast);
		}
//		if (foundNode(n))
//		{
			//Solver checkSolver = slc.typeSystem().createSolver(((ProcedureDecl) n).name());
			//slc.solver = checkSolver;
//		}
		return this;
	}

	@Override
	public Node leaveCall(Node old, Node n, NodeVisitor nv) throws SemanticException
	{
		if (foundNode(n))
		{
			// here we modify n (replace arglabels with summary var labels)
			//Node summaryNode = replaceArgLabelsWithSummaryVarLabels((JifProcedureDecl) n);
			try {
				ProcedureDecl pd = (ProcedureDecl) n;
				JifProcedureInstance jpi = (JifProcedureInstance) pd.procedureInstance();

				slc.labelCheck(pd);
				// slc now contains all of the constraints generated by label checking n, with
				// summary variables
//				slc.reportSummaryConstraintSet(pd, 3);
				//summaryInfo.setSummaryConstraints(jpi, slc.getSummaryConstraints());
			}
			catch (SemanticException e) {
				throw e;
			}
		}

		return n;
	}

	private boolean foundNode(Node n)
	{
		if (n instanceof ProcedureDecl) {
			ProcedureDecl jpd = (ProcedureDecl) n;
			if (jpd.procedureInstance().equals(method)) {
				if (Report.should_report("summary", 5))
					Report.report(5,"we found the node -- " + n + "@" + n.position());
				return true;
			}
		}

		return false;
	}

	public void run() {
		// thread begins -- visit the AST
		ast.visit(this);
	}
}
